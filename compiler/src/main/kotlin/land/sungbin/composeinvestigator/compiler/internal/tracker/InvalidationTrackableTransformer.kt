/*
 * Designed and developed by Ji Sungbin 2023.
 *
 * Licensed under the MIT.
 * Please see full license: https://github.com/jisungbin/ComposeInvestigator/blob/main/LICENSE
 */

package land.sungbin.composeinvestigator.compiler.internal.tracker

import androidx.compose.compiler.plugins.kotlin.analysis.StabilityInferencer
import androidx.compose.compiler.plugins.kotlin.analysis.normalize
import land.sungbin.composeinvestigator.compiler.internal.COMPOSABLE_INVALIDATION_EFFECT_FQN
import land.sungbin.composeinvestigator.compiler.internal.COMPOSABLE_INVALIDATION_EFFECT_IMPL_FQN
import land.sungbin.composeinvestigator.compiler.internal.irInt
import land.sungbin.composeinvestigator.compiler.internal.irString
import land.sungbin.composeinvestigator.compiler.internal.origin.InvalidationTrackerOrigin
import land.sungbin.composeinvestigator.compiler.internal.stability.toIrDeclarationStability
import land.sungbin.composeinvestigator.compiler.internal.tracker.key.DurableWritableSlices
import land.sungbin.composeinvestigator.compiler.internal.tracker.key.irTracee
import land.sungbin.composeinvestigator.compiler.internal.tracker.logger.InvalidationLogger
import land.sungbin.composeinvestigator.compiler.internal.tracker.table.propGetter
import land.sungbin.composeinvestigator.compiler.util.VerboseLogger
import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext
import org.jetbrains.kotlin.ir.IrStatement
import org.jetbrains.kotlin.ir.UNDEFINED_OFFSET
import org.jetbrains.kotlin.ir.declarations.IrSimpleFunction
import org.jetbrains.kotlin.ir.expressions.IrBlock
import org.jetbrains.kotlin.ir.expressions.IrCall
import org.jetbrains.kotlin.ir.expressions.IrConst
import org.jetbrains.kotlin.ir.expressions.addElement
import org.jetbrains.kotlin.ir.expressions.impl.IrBlockImpl
import org.jetbrains.kotlin.ir.expressions.impl.IrCallImpl
import org.jetbrains.kotlin.ir.expressions.impl.IrVarargImpl
import org.jetbrains.kotlin.ir.symbols.IrSimpleFunctionSymbol
import org.jetbrains.kotlin.ir.types.defaultType
import org.jetbrains.kotlin.ir.types.impl.makeTypeProjection
import org.jetbrains.kotlin.ir.types.typeWithArguments
import org.jetbrains.kotlin.ir.util.dump
import org.jetbrains.kotlin.ir.util.dumpKotlinLike
import org.jetbrains.kotlin.ir.util.kotlinFqName
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.types.Variance

internal class InvalidationTrackableTransformer(
  private val context: IrPluginContext,
  private val logger: VerboseLogger,
  private val stabilityInferencer: StabilityInferencer,
) : AbstractInvalidationTrackingLower(context, logger), IrPluginContext by context {
  private var composableInvalidationEffectImplSymbol: IrSimpleFunctionSymbol? = null

  override fun visitComposableBlock(function: IrSimpleFunction, expression: IrBlock): IrBlock {
    val newStatements = mutableListOf<IrStatement>()

    val currentKey = irTracee[DurableWritableSlices.DURABLE_FUNCTION_KEY, function]!!
    val currentUserProvideName = currentKey.userProvideName

    val currentFunctionName = currentUserProvideName ?: function.name.asString()
    val currentFunctionLocation = function.getSafelyLocation()
    val currentInvalidationTrackTable = currentInvalidationTrackTable!!

    val composableInvalidationEffectCallToImplTransformResult =
      expression.transformComposableInvalidationEffectCallToImpl(
        composableKey = irString(currentKey.keyName),
        tableGetter = currentInvalidationTrackTable.propGetter(),
      )

    val paramInfoType = InvalidationLogger.paramInfoSymbol!!.defaultType
    val paramInfoGenericTypeProjection = makeTypeProjection(type = paramInfoType, variance = Variance.OUT_VARIANCE)
    val paramInfoGenericType = irBuiltIns.arrayClass.typeWithArguments(listOf(paramInfoGenericTypeProjection))
    val paramInfos = IrVarargImpl(
      startOffset = UNDEFINED_OFFSET,
      endOffset = UNDEFINED_OFFSET,
      type = paramInfoGenericType,
      varargElementType = paramInfoType,
    )

    // The last two arguments are generated by the Compose compiler ($composer, $changed)
    val validValueParamters = function.valueParameters.dropLast(2)
    for (param in validValueParamters) {
      val name = irString(param.name.asString())
      val valueGetter = irGetValue(param)
      val valueString = irToString(valueGetter)
      val valueHashCode = irHashCode(valueGetter)
      val stability = stabilityInferencer.stabilityOf(valueGetter).normalize().toIrDeclarationStability(context)

      val paramInfo = InvalidationLogger.irParameterInfo(
        name = name,
        valueString = valueString,
        valueHashCode = valueHashCode,
        stability = stability,
      )
      val paramInfoVariable = irTmpVariableInCurrentFun(paramInfo, nameHint = "${param.name.asString()}\$paramInfo")

      newStatements += paramInfoVariable
      paramInfos.addElement(irGetValue(paramInfoVariable))
    }

    val computeInvalidationReason =
      currentInvalidationTrackTable.irComputeInvalidationReason(
        composableKeyName = irString(currentKey.keyName),
        parameterInfos = paramInfos,
      )
    val computeInvalidationReasonVariable = irTmpVariableInCurrentFun(
      computeInvalidationReason,
      nameHint = "$currentFunctionName\$validationReason",
    )
    newStatements += computeInvalidationReasonVariable

    // TODO: Improve default log message
    val defaultMessage = irString("[INVALIDATION_TRACKER] <${getCurrentFunctionNameIntercepttedAnonymous(currentUserProvideName)}> invalidation processed")
    val affectedComposable = InvalidationLogger.irAffectedComposable(
      composableName = irString(currentFunctionName),
      packageName = irString(getCurrentFunctionPackage()),
      filePath = irString(currentFunctionLocation.file),
      startLine = irInt(currentFunctionLocation.line),
      startColumn = irInt(currentFunctionLocation.column),
    )
    val invalidationTypeSymbol = InvalidationLogger.irInvalidationTypeSymbol()
    val invalidationTypeProcessed =
      InvalidationLogger.irInvalidationTypeProcessed(reason = irGetValue(computeInvalidationReasonVariable))
        .apply { type = invalidationTypeSymbol.defaultType }

    val callListeners = currentInvalidationTrackTable.irCallListeners(
      key = irString(currentKey.keyName),
      composable = affectedComposable,
      type = invalidationTypeProcessed,
    )
    val logger = InvalidationLogger.irLog(
      affectedComposable = affectedComposable,
      invalidationType = invalidationTypeProcessed,
      defaultMessage = defaultMessage,
    )
    newStatements += listOf(callListeners, logger)

    if (composableInvalidationEffectCallToImplTransformResult != null) {
      val (index, newCall) = composableInvalidationEffectCallToImplTransformResult
      expression.statements.removeAt(index)
      expression.statements.add(index, newCall)
    }

    expression.statements.addAll(1, newStatements)
    expression.origin = InvalidationTrackerOrigin

    logger("[invalidation processed] dump: ${expression.dump()}")
    logger("[invalidation processed] dumpKotlinLike: ${expression.dumpKotlinLike()}")

    return expression
  }

  override fun visitSkipToGroupEndCall(function: IrSimpleFunction, expression: IrCall): IrBlock {
    val currentKey = irTracee[DurableWritableSlices.DURABLE_FUNCTION_KEY, function]!!
    val currentUserProvideName = currentKey.userProvideName

    val currentFunctionName = currentUserProvideName ?: function.name.asString()
    val currentFunctionLocation = function.getSafelyLocation()
    val currentInvalidationTrackTable = currentInvalidationTrackTable!!

    // TODO: Improve default log message
    val defaultMessage = irString("[INVALIDATION_TRACKER] <${getCurrentFunctionNameIntercepttedAnonymous(currentUserProvideName)}> invalidation skipped")
    val affectedComposable = InvalidationLogger.irAffectedComposable(
      composableName = irString(currentFunctionName),
      packageName = irString(getCurrentFunctionPackage()),
      filePath = irString(currentFunctionLocation.file),
      startLine = irInt(currentFunctionLocation.line),
      startColumn = irInt(currentFunctionLocation.column),
    )
    val invalidationTypeSymbol = InvalidationLogger.irInvalidationTypeSymbol()
    val invalidationTypeSkipped = InvalidationLogger.irInvalidationTypeSkipped()
      .apply { type = invalidationTypeSymbol.defaultType }

    val callListeners = currentInvalidationTrackTable.irCallListeners(
      key = irString(currentKey.keyName),
      composable = affectedComposable,
      type = invalidationTypeSkipped,
    )
    val logger = InvalidationLogger.irLog(
      affectedComposable = affectedComposable,
      invalidationType = invalidationTypeSkipped,
      defaultMessage = defaultMessage,
    )

    val block = IrBlockImpl(
      startOffset = UNDEFINED_OFFSET,
      endOffset = UNDEFINED_OFFSET,
      type = irBuiltIns.unitType,
      origin = InvalidationTrackerOrigin,
      statements = listOf(callListeners, logger, expression),
    )

    logger("[invalidation skipped] transformed: ${expression.dumpKotlinLike()} -> ${block.dumpKotlinLike()}")

    return block
  }

  private fun IrBlock.transformComposableInvalidationEffectCallToImpl(
    composableKey: IrConst<String>,
    tableGetter: IrCall,
  ): Pair<Int, IrCall>? {
    var foundIndex: Int? = null
    var foundStatement: IrCall? = null

    for ((index, statement) in statements.withIndex()) {
      if (statement is IrCall) {
        if (statement.symbol.owner.kotlinFqName == COMPOSABLE_INVALIDATION_EFFECT_FQN) {
          foundIndex = index
          foundStatement = statement
          break
        }
      }
    }

    if (foundIndex != null && foundStatement != null) {
      val givenKeys = foundStatement.getValueArgument(0)
      val givenBlock = foundStatement.getValueArgument(1)
      val givenComposer = foundStatement.getValueArgument(2)
      val givenChanged = foundStatement.getValueArgument(3)

      if (composableInvalidationEffectImplSymbol == null) {
        composableInvalidationEffectImplSymbol =
          context
            .referenceFunctions(
              CallableId(
                packageName = COMPOSABLE_INVALIDATION_EFFECT_IMPL_FQN.parent(),
                callableName = COMPOSABLE_INVALIDATION_EFFECT_IMPL_FQN.shortName(),
              ),
            )
            .single()
      }

      return foundIndex to IrCallImpl.fromSymbolOwner(
        startOffset = UNDEFINED_OFFSET,
        endOffset = UNDEFINED_OFFSET,
        symbol = composableInvalidationEffectImplSymbol!!,
      ).apply {
        putValueArgument(0, composableKey)
        putValueArgument(1, tableGetter)
        putValueArgument(2, givenKeys)
        putValueArgument(3, givenBlock)
        putValueArgument(4, givenComposer)
        putValueArgument(5, givenChanged)
      }
    }

    return null
  }
}
